import type { Project } from "../schema/project";
import { extractImports, dedupeImports } from "./importDedupe";

export interface BlockRange {
  blockId: string;
  title: string;
  index: number;
  startLine: number;
  endLine: number;
}

export interface MainConcatResult {
  mainPy: string;
  ranges: BlockRange[];
}

export function buildMainPy(project: Project, order: string[]): MainConcatResult {
  const nodeById = new Map(project.nodes.map((node) => [node.id, node]));
  const ranges: BlockRange[] = [];
  const lines: string[] = [];

  lines.push("# Generated by MLBlocks");
  lines.push(`# Project: ${project.name}`);
  lines.push(`# Generated at: ${new Date().toISOString()}`);
  lines.push("");

  const importLines: string[] = [];
  const blockBodies: { id: string; title: string; body: string }[] = [];

  order.forEach((id) => {
    const node = nodeById.get(id);
    if (!node) {
      return;
    }
    const { imports, body } = extractImports(node.code);
    importLines.push(...imports);
    blockBodies.push({ id, title: node.title, body });
  });

  const uniqueImports = dedupeImports(importLines);
  if (uniqueImports.length > 0) {
    lines.push(...uniqueImports);
    lines.push("");
  }

  blockBodies.forEach((block, index) => {
    const startLine = lines.length + 1;
    lines.push(`# ===== BLOCK START ${block.id} | ${String(index + 1).padStart(3, "0")} | ${block.title} =====`);
    lines.push(`# __MLBLOCK_NODE_ID__ = "${block.id}"`);
    if (block.body.trim().length > 0) {
      lines.push(...block.body.split(/\r?\n/));
    }
    lines.push(`# ===== BLOCK END ${block.id} =====`);
    const endLine = lines.length;
    ranges.push({
      blockId: block.id,
      title: block.title,
      index: index + 1,
      startLine,
      endLine
    });
    lines.push("");
  });

  return { mainPy: lines.join("\n"), ranges };
}

